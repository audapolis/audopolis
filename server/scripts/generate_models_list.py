from collections import defaultdict
from pathlib import Path

import requests
import yaml
from bs4 import BeautifulSoup

HARDCODED_MODELS = [
    {
        "lang": "German",
        "name": "punctuator2-subtitle2go",
        "url": (
            "https://github.com/bugbakery/audapolis-model-hub/releases/download/2"
            "/Model_subs_norm1_filt_5M_tageschau_euparl_h256_lr0.02.zip"
        ),
        "description": (
            "Punctuation Model trained by the "
            "Language Technology Group of the Universität Hamburg (UHH)"
        ),
        "size": "213M",
        "type": "punctuation",
        "compressed": False,
    },
    {
        "lang": "English",
        "name": "punctuator2-europarl",
        "url": (
            "https://github.com/bugbakery/audapolis-model-hub/releases/download/2/"
            "Demo-EUROPARL-EN.zip"
        ),
        "description": (
            "Model trained on the Europarl dataset by Ottokar Tilk and Tanel Alumäe "
            "of the Language Technology Laboratory at Tallinn University of Technology"
        ),
        "size": "138M",
        "type": "punctuation",
        "compressed": False,
    },
]

r = requests.get("https://alphacephei.com/vosk/models")
assert r.status_code == 200
soup = BeautifulSoup(r.content, "html.parser")
table = soup.find("table")

columns = [x.text for x in table.find_all("th")]
rows = table.find("tbody").find_all("tr")

models = HARDCODED_MODELS
current_lang = None
for row in rows:
    if strong := row.find("strong"):
        current_lang = strong.text
    else:
        assert (
            current_lang is not None
        ), "no previous language heading found, probably the format changed :("
        raw = {k: v for k, v in zip(columns, row.find_all("td"))}

        if current_lang == "English Other" or "not" in raw["Notes"].text.lower():
            continue

        if current_lang == "Speaker identification model":
            continue

        name = "big"
        possible_names = ["small", "nano", "zamia", "linto-2.0", "linto-2.2", "lgraph"]
        for possible_name in possible_names:
            if possible_name in raw["Model"].text:
                name = possible_name
                break

        model = dict(
            lang=current_lang,
            name=name,
            url=raw["Model"].find("a").get("href"),
            description=raw["Notes"].decode_contents(),
            size=raw["Size"].text,
            type="transcription",
            compressed=True,
        )
        models += [model]


def print_table_from_dict_list(dict_list, columns=None):
    from rich.console import Console
    from rich.table import Table

    table = Table()
    if columns is None:
        columns = set()
        for d in dict_list:
            columns |= set(d.keys())

    for c in columns:
        table.add_column(c)
    for d in dict_list:
        table.add_row(*[d.get(c, "") for c in columns])

    console = Console()
    console.print(table)


print_table_from_dict_list(models, columns=["lang", "name", "url"])

by_language = defaultdict(list)
for model in models:
    lang = model["lang"]
    del model["lang"]
    by_language[lang] += [model]

with open(Path(__file__).parent.parent / "app" / "models.yml", "w") as outfile:
    outfile.write(
        "# this file is autogenerated by the "
        "../scripts/generate_models_list.py script.\n"
        "# do not edit manually!\n\n"
    )
    yaml.dump(dict(by_language), outfile, sort_keys=False)
